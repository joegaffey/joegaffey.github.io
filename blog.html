
<h2>The importance of Unix philosophy in modern "App" UX</h2>
<h4>Posted: 28-11-11</h4>
<p>There has been a lot of debate recently on web vs. app as a platform and delivery mechanism for mobile computing. This has been quite distracting as it tends to focus discussion on the platform and away from the core problem of delivering the best possible UX.</p>
<p>So, to get this out of the way, lets simply call an app short form for the <em>application</em> of a computation engine to solve a user problem. This should cover desktop, web, cloud, mobile, abacus or whatever you're having yourself as a colleague of mine is fond of saying.</p>
<p>A common element of the app trend, independent of delivery mechanism, is simplicity and task focus. Modern apps need to be simple single purpose, to do one thing and do it well. Apps that shun or stray away from this philosophy sacrifice simplicity for features and in general tend to suffer hugely for that. The term KISS (Keep It Simple, Stupid) could be well applied here. This term is often used as a summary of the Unix philosophy i.e. that of providing simple single purpose programs with well defined interfaces.<span id="more-223"></span>This fundamental approach is driving the app economy by which I'm not just referring to the native mobile markets but also desktop and web app markets, walled garden web app platforms and the "appification" of the open web as a collection of single purpose sites designed with the intention of attracting users and hence revenue by focussing on a single task and nailing it.</p>
<p>What will turn this trend into a fully fledged computing revolution is the ability of apps to integrate seamlessly on demand to satisfy the myriad complex user scenarios encountered in the everyday life of everyone on the planet. The level of sophistication required to achieve this is incredibly difficult to achieve in a monolithic application and even more difficult to adapt as the users needs change. This was well understood by the creators of the Unix platform. Douglas McIlroy, the inventor of Unix pipes one of the fundamental building blocks of Unix programming wrote the following:</p>
<p><em>"This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface."</em></p>
<p>This approach facilitates the combination of any number of single purpose programs via the pipe construct (i.e. data is piped between them) to implement a composite application which addresses a given user need. Composite apps can likewise be further composed into higher functioning apps.  The power afforded by this enables huge levels of productivity for the Unix user with the ability to take advantage of it.</p>
<p>One might ask therefore if the enlightened of the Unix world had this all worked out generations ago, why is it that the rest of us are only now beginning to see the light. The reason in my opinion is appropriate UX. The designers and users of Unix tended [sic] to be alpha geeks, individuals for whom whipping out a text editor and knocking out a script or compiled app wouldn't cause a second thought - power users. They had neither the need for or inclination to use interfaces designed for normal mortals and preferred the efficiency of command line editors with impenetrable syntax and minimal help. Of course, even these niceties were mainly for the slow ones who couldn't rely on simply piping their command log to a file at the end of a session and calling it a day.</p>
<p>What allowed these alpha users to be so productive was primarily the underlying philosophy but also the knowledge of the collection of programs and the environment that allowed them to be so effectively composed. This knowledge effectively separates the world into people who understand Unix and consider it simple and people who either consider Unix complex or have never heard of it.</p>
<p>So basically, while the system is inherently simple, the learning curve is through the roof and acts as a massive barrier to entry. This does not mean however that the underlying philosophy is incorrect, it just means that the UX, while appropriate for the target users, is unsuitable for mass market or consumer facing usage.</p>
<p>So UX is important in empowering users - stop the presses! That may be an obvious statement but perhaps, what is not so obvious is the power that can be tapped into by combining task focused apps with ease of composition via simple user interfaces. One of the main benefits of simple composition is the ability to construct sophisticated workflows that are reactive to the user context. This is incredibly complex for a monolithic application to address but simple for a web of connected apps where the user may choose the most appropriate tool for the task at hand at any given moment. This is the norm for the Unix power user but has not until recently been available to regular users in the broader computing world.</p>
<p>This power is compounded as the user interface crosses device and form factor boundaries and begins to look like the sci-fi vision of ubiquitous computing that we often see in the movies. How far are we really from this vision though? The technology is largely in place and while the usual business and competition barriers exist, the main remaining issue to be addressed in my opinion is the broader adoption of the philosophy in our app user interfaces including both a simple task focussed design and simple integration and composition. These issues are more related to UX design than technology and once the benefits are apparent, standards and interoperability will follow.</p>
<p>The use of intents on the <a href="http://developer.android.com/guide/topics/intents/intents-filters.html">Android</a> platform and now on the <a href="http://webintents.org/">web</a> is an example of an attempt to harness some of the power and flexibility of the Unix philosophy in modern apps in a much more user friendly manner. In this case the platform is a web page or smartphone rather than a server terminal, the mechanism is the action prompt rather than a Unix pipe and the data transferred is the action target object rather than plain ASCII text.</p>
<p>The overall effect towards the end user is basically the same however. The user can easily choose how the output of one app is fed into another. This time however, the user is not a power user with a deep knowledge of a limited exposure platform. It is anyone who can surf the web or use a smartphone and this is the kind of user that heralds computing revolutions.</p>